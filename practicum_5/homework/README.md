# Домашнее задание "Сжатие временного ряда с потерями"

## Постановка задачи

Реализовать алгоритм сжатия с потерями с помощью квантизации и алгоритма Хаффмана. Более конкретно, необходимо реализовать классы `LossyCompression` и `HuffmanCoding` в файле `huffman.py`. Чтобы упростить реализацию, в данном домашнем задании сжатая последовательность представляется в виде битовой строки, например "011000101". Именно по этой причине методы `LossyCompression.compress()` и `HuffmanCoding.encode()` возвращают `str`. 

## Ожидаемый результат

Заполненный файл `huffman.py`, запускаемый без ошибок из корня репозитория
```bash
$ python practicum_5/homework/huffman.py
```
Для этого также необходимо скачать файл с временным рядом и расположить его в корне репозитория: https://drive.google.com/file/d/1aK6rjiWItiKCYLmU_-sguOvkOAG3CSGg/view?usp=sharing 

## Необходимая теория

### Квантизация

Предоставленный временной ряд $X_t \in \mathbb{R}$, $1 \leq t \leq T$, является последовательностью вещественных чисел, в то время как классические алгоритмы сжатия работают с дискретными алфавитами.
В таком случае пригождается квантизация, которая аппроксимирует вещественные числа конечным набором чисел, и является примером сжатия с потерями.
Простейшим случаем является min-max квантизация.
Для алфавита размером $K$ она строит $K$ равных интервалов $\{(z_i, z_{i+1})\}_{i=1}^{K}$, где $z_1 = \min_t(X_t)$ и $z_{K+1} = \min_t(X_t)$, а сам алфавит состоит из центров данных интервалов $\xi_i = (z_i + z_{i+1}) / 2$.
В процессе квантизации значение временного ряда $X_t$ заменяется на $\xi_i$, если $X_t \in (z_i, z_{i+1})$.
При решении данного задания вы можете реализовать как min-max квантизацию, так и более сложную квантизацию.

### Код Хаффмана

Кодом называют отображение исходного алфавита символов (они могут иметь произвольный тип) в кодовые слова, где каждое кодовое слово является последовательностью бит.

Алгоритм Хаффмана позволяет построить оптимальный префиксный код, то есть такой код, где ни одно кодовое слово не является префиксом другого. Например, код $\{A: 0, B: 10, C: 110, D: 111\}$ является префиксным кодом.
Префиксный код удобно представлять в виде бинарного дерева, листьями которого являются символы алфавита, а ребра ассоциируются с битами 0 или 1.

![huffman tree](images/huffman_tree.svg)

Построение оптимального префиксного кода в таком случае эквивалентно построению оптимального кодового дерева, минимизирующего следующую стоимость:
$$
Cost = \sum_{i = 1}^{K} f_i d_i,
$$
где $f_i$ является частотой $i$-го символа, а $d_i$ его глубиной в кодовом дереве.

Код Хаффмана является оптимальным решением этой задачи.
В его кодовом дереве два символа с наименьшей частотой располагаются на самом нижнем уровне дерева, и их родителем объявляется "фейковый" символ, как бы объединяющих их и имеющий частоту равную сумме их частот.
Этот фейковый символ, обозначенный ниже как symbol$(f_{(1)}, f_{(2)})$, добавляется в алфавит, а два предыдущих символа удаляются.

![huffman tree](images/huffman_1.svg)

Далее процедура повторяется - мы снова выбираем два символа с наименьшей частотой, помня, что теперь нам может попасться и фейковый символ, и подвешиваем их под общим родителем.
Так будет выглядеть кодовое прото-дерево, если ни один из извлеченных символа не является фейковым:

![huffman tree](images/huffman_2_1.svg)

А так оно будет выглядеть, если один из извлеченных символов является фейковым:

![huffman tree](images/huffman_2_2.svg)

