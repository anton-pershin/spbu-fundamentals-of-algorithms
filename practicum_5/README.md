# Минимальное остовное дерево (minimum spanning tree, MST)

> ### Определение (MST)
> Минимальным остовным деревом (MST) неориентированного взвешенного графа $G = (V, E)$ с весами $w_e$, $e \in E$, называют дерево $T = (V, E^{\prime})$, $E^{\prime} \subseteq E$, минимизирующее суммарный вес ребер:
$$
\text{weight}(T) = \sum_{e \in E^{\prime}} w_e.
$$
>
> ![graph mst](images/graph_mst.svg)

Напомним, что дерево по определению является связным ациклическим графом. Следовательно, в MST всегда найдется путь между произвольными вершинами $u, v \in V$.

> ### Определение (разрез, cut)
> Разрезом (cut) называется любое разбиение вершин графа $G = (V, E)$ на $S$ и $V \backslash S$.
>
> ![graph cut](images/graph_cut.svg)

> ### Свойство разреза
> Пусть ребра множества $X$ входят в MST графа $G = (V, E)$. Пусть $S \subseteq V$ и $V \backslash S$ задают разрез, и ни одно ребро из $X$ не соединяет вершину из $S$ с вершиной из $V \backslash S$. Пусть $e$ является наименьшим по весу ребром, соединяющим $S$ с $V \backslash S$. Тогда $X \cup \{e\}$ является частью некоторого MST.
>
> ![graph cut property](images/graph_cut_property.svg)

Свойство разреза позволяет сформулировать два известных алгоритма построения MST - алгоритм Крускала (Kruskal's algorithm) и алгоритм Прима (Prim's algorithm). Оба алгоритма являются жадными.

### Алгоритм Крускала

Алгоритм Крускала сначала сортирует все ребра по возрастанию весов и затем добавляет их в прото-MST до тех пор, пропуская ребра, создающие циклы. Для его реализации нам понадобится структура данных "система непересекающихся множеств" (disjoint sets), имеющая три операции:
- `make_set(x)`: создает одноэлементное множество $\{x\}$
- `find(x)`: возвращает множество, включающее в себя $x$
- `union(x, y)`: объединяет множества, включающие в себя $x$ и $y$

Множества этой системы будут компонентами связности графа на текущей итерации алгоритма Крускала. Мы инициализируем алгоритм Крускала с помощью `make_set(v)`, вызванного для каждой вершины $v \in V$.  

![graph kruskal](images/graph_kruskal_1.svg)

Далее мы итерируемся по отсортированному списку ребер и, если ребро соединяет две компоненты связности (два множества в терминах disjoint sets), то мы добавляем его в MST и объединяем соответствующие компоненты связности с помощью `union(v, u)`. Три итерации алгоритма Крускала, изображенные ниже, демонстрируют простой случай, когда очередное ребро соединяет две компоненты связности.  

![graph kruskal](images/graph_kruskal_2.svg)

![graph kruskal](images/graph_kruskal_3.svg)

![graph kruskal](images/graph_kruskal_4.svg)

Следующая итерация, однако, чуть более сложная - ребро $(D, G)$, несмотря на наименьший среди доступных ребер вес, должно быть отброшено, так как оно соединяет вершины, принадлежащие одному множеству / одной компоненте связности. Следующее по списку ребро, $(B, F)$, соединяет различные компоненты связности и, следовательно, подходит для добавления в MST. 

![graph kruskal](images/graph_kruskal_5.svg)

### Алгоритм Прима

Гораздо более простой алгоритм, известный как алгоритм Прима, можно получить, если использовать свойство разреза напрямую. В этом случае мы начинаем с произвольной вершины $v \in V$ и формируем из нее множество $S = \{v\}$. Нам также понадобится очередь с приоритетом $Queue$, позволяющая хранить текущие ребра, соединяющие $S$ с $V \backslash S$, где приоритет задается весом (очередное извлекаемое ребро должно иметь наименьший вес). В нашем примере мы начинаем с вершины $A$, то есть $S = \{A\}$, так что в очередь добавляются ребра (A, C), (A, D) и (A, B). $Queue$ располагает ребро (A, C) впереди очереди, и именно оно будет извлечено на очередной итерации и добавлено в MST.

![graph prim](images/graph_prim_1.svg)

Это приводит к добавлению $C$ в множество $S$, то есть $S = S \cup \{C\}$, и к добавлению нового ребра (C, F), соединяющего теперь $S$ с $V \backslash S$, в $Queue$. Теперь в порядке приоритета мы извлекаем ребро (A, D) из $Queue$ и добавляем его в MST.

![graph prim](images/graph_prim_2.svg)

Этот процесс продолжается до тех пор, пока не будет достигнуто состояние $S = V$. 

![graph prim](images/graph_prim_3.svg)
