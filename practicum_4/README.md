# Поиск в глубину (depth-first search, DFS)

DFS предполагает обход графа $G = (V, E)$ в глубину, то есть при рассмотрении соседа B вершины A мы сразу переходим к соседям вершины B, а не к очередному соседу вершины A.

Рассмотрим в качестве примера следующий граф и обойдем его с помощью DFS, начав с вершины A. Заведем множество $Visited$, в которое мы будем добавлять посещенные вершины. Так как мы начинаем с вершины A, то в начальный момент $Visited = \{A\}$. Далее мы будет использовать это множество, чтобы не посещать уже посещенные вершины. Обход графа также подразумевает вывоз двух функций для каждой из вершин: previsit и postvisit. Pervisit вызывается сразу перед добавлением вершины в $Visited$. Postvisit вызывается после того, как были посещены все соседи данной вершины.

![graph from maze](images/graph_from_maze_dfs_1.svg)

Соседями A являются B, C и D. Мы посещаем первый из них, B, таким образом пополняя множество посещенных вершин $Visited = Visited \cup \{B\}$.

![graph from maze](images/graph_from_maze_dfs_2.svg)

Далее мы сразу переходим к соседям B, то есть E и F, и посещаем E: $Visited = Visited \cup \{E\}$. Формально вершина A является соседом B, но мы не посещаем ее, так как $A \in Visited$. 

![graph from maze](images/graph_from_maze_dfs_3.svg)

Аналогично мы посещаем J: $Visited = Visited \cup \{J\}$.

![graph from maze](images/graph_from_maze_dfs_4.svg)

Единственным соседом J, невходящим в $Visited$, является $I$: $Visited = Visited \cup \{J\}$.  

![graph from maze](images/graph_from_maze_dfs_5.svg)

Перейдя к $I$ мы обнаруживаем, что его соседи уже включены в $Visited$. Следовательно, мы откатываемся к ближайшей вершине в стеке, у которой есть непосещенные соседи. Этой вершиной окажется B с непосещенным соседом F. Далее DFS продолжает по той же схеме.

![graph from maze](images/graph_from_maze_dfs_6.svg)

Заметим, что DFS строит дерево поиска в глубину. Ребра, включенные в это дерево, называют древесными ребрами (tree edges). Остальные ребра, называемые обратными (back edges), были отброшены, так как они вели к уже посещенным вершинам. Полученное дерево также позволяет построить путь от A до произвольной вершины невзвешенного графа, но этот путь не является кратчайшим.  

![graph from maze](images/graph_from_maze_dfs_tree.svg)

Оценим теперь сложность DFS. Мы вынуждены посетить все вершины $v \in V$ и также мы вынуждены пройти по всем ребрам $(u, v) \in E$, чтобы убедиться, была бы посещена вершина, ассоциированная с данным ребром. Следовательно, сложность DFS по времени будет линейной, $O(|V| + |E|)$. 

# Поиск в ширину (breadth-first search)

BFS предполагает обход графа в ширину, то есть сразу после посещения соседа B вершины A мы переходим к очередному соседу вершины A, а не к соседям вершины B, как в DFS.

Рассмотрим тот же граф, что и выше, и обойдем его с помощью BFS, начав с вершины A и снова воспользовавшись множеством $Visited = \{A\}$.

![graph from maze](images/graph_from_maze_bfs_1.svg)

Соседями A являются B, C и D. Мы посещаем первого из них, B: $Visited = Visited \cup \{B\}$.

![graph from maze](images/graph_from_maze_bfs_2.svg)

Далее посещаем второго соседа, то есть C: $Visited = Visited \cup \{С\}$.

![graph from maze](images/graph_from_maze_bfs_3.svg)

Затем посещаем последнего соседа вершины A, то есть D: $Visited = Visited \cup \{D\}$. 

![graph from maze](images/graph_from_maze_bfs_4.svg)

Соседи вершины A закончились. Можем переходить к соседям первой посещенной вершины, B. Первым ее соседом является E: $Visited = Visited \cup \{E\}$. Далее BFS продолжается по той же схеме.

![graph from maze](images/graph_from_maze_bfs_5.svg)

BFS также строит дерево поиска, и в этот раз оно является деревом кратчайших путей от A до произвольных вершин в невзвешенном графе.

![graph from maze](images/graph_from_maze_bfs_tree.svg)

